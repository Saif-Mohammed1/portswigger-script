const HtmlElements = [
  "abbr",
  "a",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbra",
  "wbr",
  "a2",
  "acronym",
  "animate",
  "animatemotion",
  "animatetransform",
  "applet",
  "audio2",
  "big",
  "blink",
  "center",
  "command",
  "content",
  "custom tags",
  "dir",
  "element",
  "font",
  "frame",
  "frameset",
  "hgroup",
  "iframe2",
  "image",
  "image2",
  "image3",
  "img2",
  "input2",
  "input3",
  "input4",
  "keygen",
  "listing",
  "marquee",
  "menu",
  "menuitem",
  "multicol",
  "nextid",
  "nobr",
  "noembed",
  "noframes",
  "plaintext",
  "rb",
  "rtc",
  "set",
  "shadow",
  "slot",
  "spacer",
  "strike",
  "tt",
  "video2",
  "xmp",
];
const eventAttributes = [
  "onafterprint",
  "onafterscriptexecute",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforecopy",
  "onbeforecut",
  "onbeforeinput",
  "onbeforeprint",
  "onbeforescriptexecute",
  "onbeforetoggle",
  "onbeforeunload",
  "onbegin",
  "onblur",
  "onbounce",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncontextmenu",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onend",
  "onended",
  "onerror",
  "onfinish",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onfullscreenchange",
  "onhashchange",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onmessage",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onmousewheel",
  "onmozfullscreenchange",
  "onpagehide",
  "onpageshow",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerrawupdate",
  "onpointerup",
  "onpopstate",
  "onprogress",
  "onratechange",
  "onrepeat",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsearch",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onshow",
  "onstart",
  "onsubmit",
  "ontimeupdate",
  "ontoggle",
  "ontoggle(popover)",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onunhandledrejection",
  "onunload",
  "onvolumechange",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel",
  "onabort",
];
const svgElements = [
  "circle",
  "rect",
  "ellipse",
  "line",
  "polyline",
  "polygon",
  "path",
  "text",
  "tspan",
  "textPath",
  "use",
  "image",
  "defs",
  "symbol",
  "g",
  "clipPath",
  "mask",
  "linearGradient",
  "radialGradient",
  "pattern",
  "marker",
  "foreignObject",
  "a",
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "audio",
  "canvas",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "iframe",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "prefetch",
  "radialGradient",
  "rect",
  "script",
  "set",
  "solidColor",
  "stop",
  "style",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "title",
  "tref",
  "tspan",
  "unknown",
  "use",
  "video",
  "view",
  "vkern",
];

///////(((((1)))))//////// this method is faster than second one but sometimes felid to detect all elements because rate limit
const dataFetching = (data) => {
  const unValidData = [];
  // Create an array to store fetch promises
  const fetchPromises = [];
  //event = each element inside items
  for (let event of data) {
    const search = encodeURIComponent(`<${event}></${event}>`); // it need to change to fit requirement
    const url = `https://0af900100471f49b80ba4e4900e90035.web-security-academy.net/?search=${search}`;

    // Create a fetch promise for the current URL and push it to fetchPromises array
    fetchPromises.push(
      fetch(url)
        .then((response) => {
          console.log("Status Code:", response.status);
          console.log("event:", event);

          if (response.status === 200) return event; // Pass the event name if status is 200

          return null; // Otherwise, return null
        })
        .catch((error) => {
          console.error("Error:", error);
          console.log("error event", event);
          unValidData.push(event);

          return null; // Return null if there's an error
        })
    );
  }

  // Wait for all fetch promises to resolve
  Promise.all(fetchPromises)
    .then((results) => {
      // Filter out null values (failed requests) from the results array
      const validData = results.filter((event) => event !== null);
      console.log("validData :", validData);
      console.log("unValidData", unValidData);
    })
    .catch((error) => {
      console.error("Error waiting for fetch promises:", error);
    });
};

//((((2)))))//////// this method is not faster than first one almost like Burp intruder but sometimes it success to detect all elements because rate limit

const dataFetchingWithTryAndCatch = async (data) => {
  const unValidData = [];
  const validData = [];
  //event = each element inside data
  for (let event of data) {
    const search = encodeURIComponent(`<${event}></${event}>`); // it need to change to fit requirement
    const url = `https://0af900100471f49b80ba4e4900e90035.web-security-academy.net/?search=${search}`;
    try {
      // Create a fetch promise for the current URL and push it to fetchPromises array
      const response = await fetch(url);
      console.log("Status Code:", response.status);
      console.log("event:", event);

      if (response.status === 200) validData.push(event);
    } catch (error) {
      console.error("Error:", error);
      console.log("error event", event);
      unValidData.push(event);
    }
  }
  console.log("validDate", validData);
  console.log("unValidData", unValidData);
};

/// choose only one to run also you can run both to cheek the speed if you want

//data = HtmlElements |eventAttributes|svgElements you need to choose which one to make lop

///////(((((1)))))//////// this method is faster than second one but sometimes felid to detect all elements and not recommended if there is rate limit

//  dataFetching(HtmlElements) // delete // in the first to run this method

//((((2)))))//////// this method is not faster than first one almost like Burp intruder but sometimes it success to detect all elements because rate limit

// dataFetchingWithTryAndCatch(HtmlElements); // delete // in the first to run this method

// to run this script you need to have node environment in your system then in terminal ====> node filename.js
